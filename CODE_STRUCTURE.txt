Code Structure Overview
=======================

This document describes the current architecture of the TypeScript/Node Notion integration, organized by module and file. It is written to be detailed enough that another LLM or engineer can reason about the system and identify refactor opportunities.

Top-Level Responsibilities
--------------------------

- src/server.ts
  - Owns the Express app and the single POST /webhook endpoint.
  - Normalizes incoming Notion Automation “Send webhook” payloads into a small NormalizedEvent.
  - Loads the Dispatch Config snapshot from the cache.
  - Evaluates DispatchCommand rules against the origin page.
  - Decides whether to:
    - Do nothing (no routes matched).
    - Run the single-object path (create commands targeting the origin page).
    - Gate and trigger objective fan-out (enqueue AutomationEvent to the objective coordinator).
  - Creates commands for the single-object path (origin-only) including:
    - Target relation (`COMMANDS_TARGET_PAGE_PROP_ID`).
    - Trigger Key (`COMMANDS_TRIGGER_KEY_PROP_ID` via `COMMAND_TRIGGER_KEY` env).
    - Directive: Command (`COMMANDS_DIRECTIVE_COMMAND_PROP_ID`).
    - Optional command name/title.
  - Logs structured decisions (`dispatch_routing_decision`, `creating_dispatch_command`, fanout logs).

- src/config.ts
  - Loads and validates environment variables using dotenv.
  - Provides a typed AppConfig (port, Notion API credentials, Commands DB ids/prop ids, Dispatch Config DB id, webhook shared secret, etc.).
  - Central place where:
    - COMMANDS_DB_ID, COMMANDS_TARGET_TASK_PROP_ID, COMMANDS_TARGET_PAGE_PROP_ID,
      COMMANDS_TRIGGER_KEY_PROP_ID, COMMANDS_DIRECTIVE_COMMAND_PROP_ID
      and DISPATCH_CONFIG_DB_ID are read.
    - COMMAND_TRIGGER_KEY is read and made available to the rest of the app.

- src/notion/*
  - src/notion/client.ts
    - Global throttled Notion HTTP client.
    - Enforces 3 requests/second using an in-process queue.
    - Implements retry logic for 429 and 5xx responses with exponential backoff.
    - Exposes notionRequest(options) which all other modules use for Notion API calls.
  - src/notion/api.ts
    - Higher-level, typed wrappers on top of notionRequest:
      - getObjectiveTaskIds(objectiveId, tasksRelationPropId?)
        - Enumerates all tasks under an Objective page via GET /v1/pages/{objectiveId}/properties/{propId}, handling pagination.
      - getObjectiveIdForTask(taskId, taskObjectivePropId)
        - Reads the Objective relation off a Task page via GET /v1/pages/{taskId}/properties/{propId}.
        - Handles both “property_item” and “results[].relation” shapes.
      - getPage(pageId)
        - Fetches the full Notion page object and returns a trimmed `{ id, parent, properties }`.
    - The legacy createCommand (for fan-out to Commands DB) now only exists to support older paths; the current fan-out path builds commands directly in handleEvent using notionRequest.

Dispatch Config Module
----------------------

All logic for reading and using the Notion “Dispatch Config Demo” DB lives under src/dispatchConfig.

- src/dispatchConfig/types.ts
  - DispatchPredicate
    - { equals: Record<string, string> } – property name → expected value.
  - DispatchRoute
    - routeName: human label from the Notion `Name` title property.
    - databaseId: *normalized* origin database id (hyphens stripped, lowercased).
    - predicate?: DispatchPredicate – optional; omitted means “match all pages in that DB”.
  - FanoutMapping
    - taskDatabaseId: *normalized* Tasks DB id this fan-out rule applies to.
    - taskObjectivePropId: Task → Objective property id/name.
    - objectiveTasksPropId: Objective → Tasks relation property id (used for enumeration).
    - conditionPropertyName?: string – optional property name to gate the fan-out rule.
    - conditionValue?: string – optional value for gating (open gate if empty).
  - DispatchConfigSnapshot
    - { fanoutMappings: FanoutMapping[]; routes: DispatchRoute[] } – the in-memory config.

- src/dispatchConfig/loadRoutes.ts
  - The sole place where the Dispatch Config DB is read and interpreted.
  - Uses AppConfig.dispatchConfigDbId and notionRequest to:
    - POST /v1/databases/{DISPATCH_CONFIG_DB_ID}/query (no filters; reads all pages).
    - Iterate all results and build:
      - DispatchRoute entries for Rule Tyoe = DispatchCommand.
      - FanoutMapping entries for Rule Tyoe = ObjectiveFanoutConfig.
  - Schema mapping (property names → behavior):
    - Name (Title)
      - Used as routeName for both DispatchCommand rules and ObjectiveFanoutConfig rows.
    - Enabled (Checkbox)
      - If false, the row is ignored entirely.
    - Origin Database ID (Text, stored as rich_text)
      - Extracted from rich_text → originDatabaseIdRaw.
      - Normalized to databaseIdKey = lowercased, hyphens removed.
      - For DispatchCommand: route.databaseId = databaseIdKey.
      - For ObjectiveFanoutConfig: fanoutMapping.taskDatabaseId = databaseIdKey.
    - Rule Tyoe (Select)
      - “DispatchCommand” → row is a DispatchCommand route.
      - “ObjectiveFanoutConfig” → row is a fan-out config.
    - Condition 1: Property Name (Text, rich_text)
      - Extracted from rich_text; trimmed.
    - Condition 1: Value (Text, rich_text)
      - Extracted from rich_text; trimmed.
      - If empty, condition is considered an open gate and the rule applies to all pages in that DB.
    - Task → Objective Property ID (Text, rich_text)
      - For ObjectiveFanoutConfig rows.
      - The Tasks DB relation property id/name used to resolve Objective ID from a Task page.
    - Objective → Tasks Property ID (Text, rich_text)
      - For ObjectiveFanoutConfig rows.
      - The Objective DB relation property id used for enumerating tasks.
  - For each row:
    - Logs `[dispatch] config_row_evaluated` with extracted fields.
    - Logs `[dispatch] config_row_properties` with the full raw Notion properties object.
    - If originDatabaseId or ruleType is missing, logs `[dispatch] config_row_invalid` and skips it.
    - For DispatchCommand:
      - Creates a DispatchRoute with:
        - databaseId = normalized Origin Database ID.
        - predicate:
          - If both conditionPropertyName and conditionValue non-empty: { equals: { [name]: value } }.
          - Else undefined (match-all for that DB).
    - For ObjectiveFanoutConfig:
      - Validates that both Task → Objective Property ID and Objective → Tasks Property ID are non-empty.
      - Creates a FanoutMapping with optional conditionPropertyName/value for gating fan-out.

- src/dispatchConfig/cache.ts
  - Maintains an in-memory DispatchConfigSnapshot with TTL.
  - TTL_MS = 60_000 (60 seconds).
  - Behavior:
    - Cold start:
      - If cache empty: await loadDispatchConfig().
      - If load fails: throws, causing /webhook to return 500 (Notion retries).
    - Warm:
      - Returns cached snapshot immediately.
      - If now - lastLoadedAt > TTL and no refresh in progress:
        - Logs `[dispatch] config_cache_refresh_started_async`.
        - Kicks off refreshCache() in the background (stale-while-refresh).
  - refreshCache():
    - Calls loadDispatchConfig().
    - Updates cachedSnapshot and lastLoadedAt.

- src/dispatchConfig/match.ts
  - Defines DispatchEvent:
    - { originDatabaseId, originPageId, properties }.
  - extractPropertyValue(prop) → string | string[] | null:
    - status → status.name
    - select → select.name
    - multi_select → array of names
    - title / rich_text → concatenated plain_text
    - number → stringified
    - checkbox → "true" / "false"
  - matchRoutes(event, routes) → DispatchRoute[]:
    - For each route:
      - Require route.databaseId === event.originDatabaseId (both normalized).
      - If no predicate:
        - Always match; log `[dispatch] dispatch_rule_matched`.
      - Else:
        - For each [propertyName, expectedValue] in predicate.equals:
          - Read event.properties[propertyName] and extractPropertyValue.
          - For string expected: match if extracted.trim() === expected.trim().
          - For array extracted: match if any element trimmed equals expected.trim().
          - If any mismatch:
            - Log `[dispatch] dispatch_rule_mismatch` with property, expected, actual.
            - Rule does not match this event.
        - If all properties matched, log `[dispatch] dispatch_rule_matched` and include route.

Webhook Normalization and Parsing
---------------------------------

- src/sources/normalizeWebhook.ts
  - normalizeWebhookEvent(payload) → NormalizedEvent:
    - Validates `data.object === 'page'`.
    - Extracts:
      - originPageId from data.id.
      - originDatabaseId from data.parent.database_id.
      - properties as the raw Notion properties object from data.properties.
    - Does not interpret Status or any particular property; leaves everything for Dispatch rules.

- src/webhook/parse.ts
  - Legacy/general AutomationEvent parser (used by some older paths, not by the new unified /webhook).
  - parseAutomationWebhook(payload) → AutomationEvent:
    - Path A (explicit JSON fields from automation):
      - trigger_task_id | taskId (string).
      - objective_id | objectiveId (string).
      - Optional trigger_key.
    - Path B (page payload fallback):
      - data.id as taskId.
      - properties.Objective.relation[0].id as objectiveId.
      - Optional triggerKey from:
        - top-level trigger_key, or
        - properties["Trigger Key"].rich_text[0].plain_text.
  - This parser no longer computes/uses newStatus; that coupling has been removed.

Core Routing and Fanout
-----------------------

- src/server.ts
  - Sets up Express and defines:
    - GET /health
    - POST /webhook/debug (delegates to src/webhook/debug.ts)
    - POST /webhook (main entry point).
  - /webhook flow:
    1. Logs `[webhook] webhook_received` with request_id and raw body.
    2. If WEBHOOK_SHARED_SECRET is set, checks `x-webhook-secret` header.
    3. Calls normalizeWebhookEvent to get { originDatabaseId, originPageId, properties }.
    4. Loads DispatchConfigSnapshot from cache.
    5. Normalizes originDatabaseId to a key: lowercased, hyphens removed.
    6. Builds a DispatchEvent:
       - originDatabaseId: normalized key.
       - originPageId: page id.
       - properties: raw properties object.
    7. Calls matchRoutes(event, snapshot.routes) to determine which DispatchCommand rules match the origin page.
    8. Logs `[webhook] dispatch_routing_decision` with:
       - request_id
       - origin_database_id (original Notion id with dashes, for readability)
       - origin_page_id
       - fanout_applied (initially false)
       - objective_id (initially null)
       - matched_routes (names of matched DispatchCommand rules).
    9. If matchedRoutes is empty:
       - Returns 200 with { ok: true, fanout_applied: false, matched_routes: [] }.
       - Does not fan out or create any Commands.
    10. If at least one DispatchCommand matches:
        - Looks for a matching ObjectiveFanoutConfig:
          - snapshot.fanoutMappings.find(m => m.taskDatabaseId === originDatabaseIdKey).
          - If found:
            - Logs `[webhook] fanout_mapping_matched`.
            - Resolves objectiveId via getObjectiveIdForTask(originPageId, Task → Objective Property ID).
            - If objectiveId is found:
              - Logs `[webhook] fanout_started`.
              - Enqueues an AutomationEvent to the objective coordinator (see below).
              - Sets fanoutApplied = true.
    11. Single-object command creation (when fanoutApplied === false):
        - Requires:
          - commandsDbId
          - commandsTargetPagePropId
          - commandsTriggerKeyPropId
          - commandTriggerKey (COMMAND_TRIGGER_KEY).
        - For each matched route:
          - Builds a Notion page body:
            - parent.database_id = Commands DB id.
            - properties:
              - [COMMANDS_TARGET_PAGE_PROP_ID] = relation → originPageId.
              - [COMMANDS_TRIGGER_KEY_PROP_ID] = rich_text with COMMAND_TRIGGER_KEY.
              - [COMMANDS_DIRECTIVE_COMMAND_PROP_ID] = multi_select containing routeName (if configured).
              - [COMMANDS_COMMAND_NAME_PROP_ID] or Name = title containing routeName.
          - Logs `[webhook] creating_dispatch_command` with routeName and property keys.
          - POSTs /v1/pages via notionRequest.
          - Increments commandsCreated on success, logs create_command_failed on failure.
    12. Returns 200 with:
        - ok
        - request_id
        - fanout_applied
        - objective_id
        - matched_routes
        - commands_created (single-object path only; fanout-created commands are counted/logged in processor).

Objective Coordinator and Fanout Processor
------------------------------------------

- src/coordinator/objectiveCoordinator.ts
  - Manages per-objective concurrency and scheduling.
  - For each objectiveId, tracks ObjectiveState { inFlight: boolean }.
  - enqueueObjectiveEvent(event: AutomationEvent):
    - If a run is already in-flight for that objective:
      - Logs `[coordinator] objective_run_skipped_in_flight` and drops the event (no queueing).
    - Else:
      - Marks inFlight = true.
      - Kicks off runForObjective(objectiveId, event).
  - runForObjective(objectiveId, event):
    - Logs `[coordinator] run_started`.
    - Awaits handleEvent(event) from src/processor/handleEvent.ts.
    - Logs `[coordinator] run_failed` on exceptions.
    - On completion, sets inFlight = false and logs `[coordinator] run_completed`.
  - This maintains a single-flight per objective; throttling is still enforced globally by notionRequest.

- src/processor/handleEvent.ts
  - Core Objective fan-out logic driven by Dispatch rules:
    1. Given AutomationEvent { taskId, objectiveId, objectiveTasksRelationPropIdOverride?, triggerKey? }:
       - Resolves tasks under the objective via getObjectiveTaskIds(objectiveId, override?).
    2. Resolves triggerKey:
       - Uses COMMAND_TRIGGER_KEY env (config.commandTriggerKey) or event.triggerKey.
    3. Validates commands* env:
       - COMMANDS_DB_ID
       - COMMANDS_TARGET_TASK_PROP_ID
       - COMMANDS_TRIGGER_KEY_PROP_ID.
    4. Loads DispatchConfigSnapshot (routes + fanout mappings).
    5. Logs `[processor] starting fan-out` with objectiveId, triggerKey, and tasks count.
    6. For each taskId:
       - Fetches page via getPage(taskId).
       - Extracts originDatabaseIdRaw = page.parent.database_id; normalizes db key (strip hyphens, lowercase).
       - If originDatabaseIdKey null, skip and log `skip task without database parent`.
       - Builds DispatchEvent { originDatabaseId: normalized key, originPageId: page.id, properties: page.properties }.
       - Runs matchRoutes(event, snapshot.routes).
       - If no routes match:
         - Logs `[processor] task_skipped_no_matching_routes` and continues.
       - If at least one route matches:
         - For each matched route:
           - Builds command body:
             - parent.database_id = Commands DB id.
             - properties:
               - [COMMANDS_TARGET_TASK_PROP_ID] = relation → taskId.
               - [COMMANDS_TRIGGER_KEY_PROP_ID] = rich_text with triggerKey.
               - [COMMANDS_DIRECTIVE_COMMAND_PROP_ID] = multi_select containing routeName (if configured).
           - Logs `[processor] creating_dispatch_command_for_task`.
           - POSTs /v1/pages via notionRequest.
           - On success: increments created.
           - On error: increments failed and logs `[processor] create_command_failed`.
    7. Returns ProcessorResult { ok: failed === 0, created, failed }.

Legacy / Demo Sources
---------------------

- src/sources/singleObjectDemo/parseWebhook.ts
  - A specialized parser for the original “Single Object Workflow Demo” webhook payload.
  - Similar to normalizeWebhookEvent but scoped to that demo; produces a DispatchEvent-like object for that path.

- src/sources/singleObjectDemo/handle.ts
  - Legacy handler for the old `/webhook/single-object` endpoint.
  - Uses getDispatchConfigSnapshot + matchRoutes to:
    - Decide which routes match the single-object demo DB.
    - Create commands pointing to the origin page (without Trigger Key or Directive: Command in the old version).
  - This code is mostly superseded by the unified /webhook flow but still exists as a reference/demo.

Types and Shared Interfaces
---------------------------

- src/types.ts
  - AutomationEvent
    - Represents a logical fan-out job for a single Objective:
      - taskId: originating task triggering the fan-out.
      - objectiveId: Objective to fan out across.
      - triggerKey?: optional per-event override; usually use COMMAND_TRIGGER_KEY instead.
      - objectiveTasksRelationPropIdOverride?: optional override for the Objective → Tasks property id; if not set, the config default is used.
  - ProcessorResult
    - { ok: boolean; created: number; failed: number } – used by the coordinator to summarize fan-out runs.

Summary
-------

- /webhook:
  - Normalizes incoming Notion page webhook.
  - Loads typed Dispatch Config (no YAML) with DB-id normalization.
  - Uses DispatchCommand rules to decide if anything should happen.
  - Uses ObjectiveFanoutConfig rows to decide if and how to fan out.
  - Creates Commands either directly (single-object path) or via the fan-out processor, always including:
    - Target relation.
    - Directive: Command listing matched rule names.
    - Trigger Key (from COMMAND_TRIGGER_KEY env).

- DispatchConfig:
  - Entirely driven by a Notion database schema:
    - Name, Enabled, Rule Tyoe, Origin Database ID, Condition 1: fields, and optional fanout mapping fields.
  - No more YAML; rules are plain row data, with rich_text for nearly all text fields.

- Fan-out:
  - Is gated by:
    - at least one DispatchCommand match on the origin page, and
    - a matching ObjectiveFanoutConfig row for the origin DB.
  - Enumerates tasks under the Objective and applies the same Dispatch rules per task.

This structure should give a clear mental model for where to refactor or consolidate: e.g., extracting a dedicated commands/ module for command body building, centralizing property extraction utilities, or further separating config loading from matching. 


